; externe Datei als overlay laden und ausführen ...
    ; --- Dateiname ---
    ; 1) Datei öffnen (DS:DX -> ASCIIZ)
    DOS_Open mod_filename, DOS_READ_ONLY
    jnc  _open_read_ok
        
    _open_error:
        push ax
        SET_CURSOR 0, 1         ; move cursor
        pop  ax
        call DOS_handle_error_code
        ; ---
    _open_read_ok:
    
    mov  [PTR16(_cA_mod_hFile)], ax        ; Handle speichern
    
    ; 2) Größe holen: lseek end
    DOS_Seek mod_hFile, SEEK_END
    jnc  _seek_ok               ; CF = 0
    
    _seek_error:
        push ax
        SET_CURSOR 0, 1         ; move cursor
        pop  ax
        call DOS_handle_error_code
        ; ---
    _seek_ok:
    
    mov  [PTR16(mod_fsize_lo)], ax     ; DX:AX = filesize
    mov  [PTR16(mod_fsize_hi)], dx
    
    ; 3) Paragraphbedarf: (size+15)/16
    mov  ax, [PTR16(mod_fsize_lo)]
    add  ax, 15
    shr  ax, 4
    
    ; 4) allozieren (AH=48h)
    mov  bx, ax                 ; BX = Paragraphs
    mov  ah, 48h
    SysCall
    jnc  _close_ok              ; CF = 0
    
    _close_error:
        push ax
        SET_CURSOR 0, 1         ; move cursor
        pop  ax
        call DOS_handle_error_code
        ; ---
    _close_ok:
    
    mov  [PTR16(mod_seg_ovl)], ax      ; AX = Segment

    ; 5) an Dateianfang
    DOS_Seek mod_hFile, SEEK_BEGIN
    

    ; 6) lesen nach Overlay:0000  (DOS erwartet DS:DX)
    mov  bx, [PTR16(_cA_mod_hFile)]
    mov  ax, [PTR16(mod_seg_ovl)]
    mov  cx, [PTR16(mod_fsize_lo)] ; (RAW <= 64K)
    push ds
    mov  ds, ax                 ; DS = Overlay-Segment
    xor  dx, dx                 ; DS:DX = 0000h
    mov  ah, 3Fh
    int  21h
    
    mov  si, ax                 ; tatsächlich gelesene Bytes
    pop  ds
    jc   _free_err
    cmp  si, cx
    jne  _free_err              ; Sicherheitscheck (optional)

    SET_CURSOR 40, 1            ; move cursor
    PUTS_COLOR ARGV_1, 0x12     ; display SI (argument)

    ; 7) FAR CALL in Overlay:0000 (DS=CS im Modul sicherstellen)
    mov  ax, [PTR16(mod_seg_ovl)]
    mov  es, ax
    mov  ax, es
    push ds
    mov  ds, ax                 ; Modul erwartet DS=CS

    push es
    push word 0
    mov bp, sp
    call far [bp]               ; -> MODUL1.BIN (muss per RETF zurück)
    add sp, 4

    _back_from_overlay:
    ; 8) DS wieder auf CS
    pop  ds
    jmp  _exit_ok
    
    ; 9) Ressourcen aufräumen (free + close)
    _exit_read_error:
    SET_CURSOR 0, 1                     ; move cursor
    PUTS_COLOR mod_read_error, 0x1E     ; display SI (argument)
    DOS_Exit 1
    
    _free_err:
    mov  ax, [PTR16(mod_seg_ovl)]
    or   ax, ax
    jz   _no_free
    DOS_FreeMem
    jnc  _free_ok
    
    _free_error:
        SET_CURSOR 0, 1
        call DOS_handle_error_code
    _free_ok:
    jmp _close_end_ok
    
    _no_free:
    SET_CURSOR 0, 1                     ; move cursor
    PUTS_COLOR mod_free_error_no, 0x1E  ; display SI (argument)
        
    _close_err:
    SET_CURSOR 0, 2                     ; move cursor
    PUTS_COLOR mod_clos_error, 0x1E     ; display SI (argument)
    DOS_Exit 1
    
    _close_end_ok:
    DOS_Close mod_hFile, _no_close
    jc   _close_err
    jnc  _exit_ok
    jmp  _exit_ok
    
    _exit_err:
    SET_CURSOR 0, 3                     ; move cursor
    PUTS_COLOR mod_file_error, 0x1E     ; display SI (argument)
    DOS_Exit 1
    
    _no_close:
    SET_CURSOR 0, 1                    ; move cursor
    PUTS_COLOR mod_clos_error_no, 0x1E ; display SI (argument)
    DOS_Exit 1

    _exit_ok:
    ;SET_CURSOR 0, 1                    ; move cursor
    ;PUTS_COLOR mod_have_error_no, 0x1E ; display SI (argument)
    
    
    DOS_Exit 0
    
    ret
